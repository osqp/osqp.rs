/* automatically generated by rust-bindgen 0.71.1 */

use {OSQPFloat, OSQPInt};

pub const OSQP_SOLVED: osqp_status_type = 1;
pub const OSQP_SOLVED_INACCURATE: osqp_status_type = 2;
pub const OSQP_PRIMAL_INFEASIBLE: osqp_status_type = 3;
pub const OSQP_PRIMAL_INFEASIBLE_INACCURATE: osqp_status_type = 4;
pub const OSQP_DUAL_INFEASIBLE: osqp_status_type = 5;
pub const OSQP_DUAL_INFEASIBLE_INACCURATE: osqp_status_type = 6;
pub const OSQP_MAX_ITER_REACHED: osqp_status_type = 7;
pub const OSQP_TIME_LIMIT_REACHED: osqp_status_type = 8;
pub const OSQP_NON_CVX: osqp_status_type = 9;
pub const OSQP_SIGINT: osqp_status_type = 10;
pub const OSQP_UNSOLVED: osqp_status_type = 11;
#[doc = " Solver Status  *"]
pub type osqp_status_type = ::std::os::raw::c_uint;
pub const OSQP_UNKNOWN_SOLVER: osqp_linsys_solver_type = 0;
pub const OSQP_DIRECT_SOLVER: osqp_linsys_solver_type = 1;
pub const OSQP_INDIRECT_SOLVER: osqp_linsys_solver_type = 2;
#[doc = " Linear System Solvers *"]
pub type osqp_linsys_solver_type = ::std::os::raw::c_uint;
pub const OSQP_NO_PRECONDITIONER: osqp_precond_type = 0;
pub const OSQP_DIAGONAL_PRECONDITIONER: osqp_precond_type = 1;
#[doc = " Preconditioners for CG method *"]
pub type osqp_precond_type = ::std::os::raw::c_uint;
pub const OSQP_NO_ERROR: osqp_error_type = 0;
pub const OSQP_DATA_VALIDATION_ERROR: osqp_error_type = 1;
pub const OSQP_SETTINGS_VALIDATION_ERROR: osqp_error_type = 2;
pub const OSQP_LINSYS_SOLVER_INIT_ERROR: osqp_error_type = 3;
pub const OSQP_NONCVX_ERROR: osqp_error_type = 4;
pub const OSQP_MEM_ALLOC_ERROR: osqp_error_type = 5;
pub const OSQP_WORKSPACE_NOT_INIT_ERROR: osqp_error_type = 6;
pub const OSQP_ALGEBRA_LOAD_ERROR: osqp_error_type = 7;
pub const OSQP_FOPEN_ERROR: osqp_error_type = 8;
pub const OSQP_CODEGEN_DEFINES_ERROR: osqp_error_type = 9;
pub const OSQP_DATA_NOT_INITIALIZED: osqp_error_type = 10;
#[doc = "< Function not implemented in this library"]
pub const OSQP_FUNC_NOT_IMPLEMENTED: osqp_error_type = 11;
pub const OSQP_LAST_ERROR_PLACE: osqp_error_type = 12;
#[doc = " Solver Errors  *"]
pub type osqp_error_type = ::std::os::raw::c_uint;
#[doc = "  Matrix in compressed-column form.\n  The structure is used internally to store matrices in the triplet form as well,\n  but the API requires that the matrices are in the CSC format."]
#[repr(C)]
pub struct OSQPCscMatrix {
    #[doc = "< number of rows"]
    pub m: OSQPInt,
    #[doc = "< number of columns"]
    pub n: OSQPInt,
    #[doc = "< column pointers (size n+1); col indices (size nzmax) starting from 0 for triplet format"]
    pub p: *mut OSQPInt,
    #[doc = "< row indices, size nzmax starting from 0"]
    pub i: *mut OSQPInt,
    #[doc = "< numerical values, size nzmax"]
    pub x: *mut OSQPFloat,
    #[doc = "< maximum number of entries"]
    pub nzmax: OSQPInt,
    #[doc = "< number of entries in triplet matrix, -1 for csc"]
    pub nz: OSQPInt,
    #[doc = "< 1 if the p, i and x pointers were allocated automatically, 0 if they are owned by the user"]
    pub owned: OSQPInt,
}
#[doc = " User settings"]
#[repr(C)]
pub struct OSQPSettings {
    #[doc = "< device identifier; currently used for CUDA devices"]
    pub device: OSQPInt,
    #[doc = "< linear system solver to use"]
    pub linsys_solver: osqp_linsys_solver_type,
    #[doc = "< boolean; allocate solution in OSQPSolver during osqp_setup"]
    pub allocate_solution: OSQPInt,
    #[doc = "< boolean; write out progress"]
    pub verbose: OSQPInt,
    #[doc = "< integer; level of detail for profiler annotations"]
    pub profiler_level: OSQPInt,
    #[doc = "< boolean; warm start"]
    pub warm_starting: OSQPInt,
    #[doc = "< data scaling iterations; if 0, then disabled"]
    pub scaling: OSQPInt,
    #[doc = "< boolean; polish ADMM solution"]
    pub polishing: OSQPInt,
    #[doc = "< ADMM penalty parameter"]
    pub rho: OSQPFloat,
    #[doc = "< boolean; is rho scalar or vector?"]
    pub rho_is_vec: OSQPInt,
    #[doc = "< ADMM penalty parameter"]
    pub sigma: OSQPFloat,
    #[doc = "< ADMM relaxation parameter"]
    pub alpha: OSQPFloat,
    #[doc = "< maximum number of CG iterations per solve"]
    pub cg_max_iter: OSQPInt,
    #[doc = "< number of consecutive zero CG iterations before the tolerance gets halved"]
    pub cg_tol_reduction: OSQPInt,
    #[doc = "< CG tolerance (fraction of ADMM residuals)"]
    pub cg_tol_fraction: OSQPFloat,
    #[doc = "< Preconditioner to use in the CG method"]
    pub cg_precond: osqp_precond_type,
    #[doc = " rho stepsize adaption method"]
    pub adaptive_rho: OSQPInt,
    #[doc = " Interval between rho adaptations\n\n When adaptive_rho == OSQP_ADAPTIVE_RHO_UPDATE_ITERATIONS, this is the number of iterations\n between rho updates.\n\n Not used when adaptive_rho is any other value."]
    pub adaptive_rho_interval: OSQPInt,
    #[doc = " Adaptation parameter controlling when non-fixed rho adaptations occur.\n\n - When adaptive_rho == OSQP_ADAPTIVE_RHO_UPDATE_TIME, this is the fraction of the\n   setup time to use as the rho adaptation interval.\n - When adaptive_rho == OSQP_ADAPTIVE_RHO_UPDATE_KKT_ERROR, this is the fraction of\n   the previous KKT error to adapt rho at.\n - Not used for any other adaptive_rho value."]
    pub adaptive_rho_fraction: OSQPFloat,
    #[doc = " Tolerance applied when adapting rho.\n\n New rho must be X times larger or smaller than the current one to change it"]
    pub adaptive_rho_tolerance: OSQPFloat,
    #[doc = "< maximum number of iterations"]
    pub max_iter: OSQPInt,
    #[doc = "< absolute solution tolerance"]
    pub eps_abs: OSQPFloat,
    #[doc = "< relative solution tolerance"]
    pub eps_rel: OSQPFloat,
    #[doc = "< primal infeasibility tolerance"]
    pub eps_prim_inf: OSQPFloat,
    #[doc = "< dual infeasibility tolerance"]
    pub eps_dual_inf: OSQPFloat,
    #[doc = "< boolean; use scaled termination criteria"]
    pub scaled_termination: OSQPInt,
    #[doc = "< integer, check termination interval; if 0, checking is disabled"]
    pub check_termination: OSQPInt,
    #[doc = "< Boolean; use duality gap termination criteria"]
    pub check_dualgap: OSQPInt,
    #[doc = "< maximum time to solve the problem (seconds)"]
    pub time_limit: OSQPFloat,
    #[doc = "< regularization parameter for polishing"]
    pub delta: OSQPFloat,
    #[doc = "< number of iterative refinement steps in polishing"]
    pub polish_refine_iter: OSQPInt,
}
#[doc = " Information about the solution process."]
#[repr(C)]
pub struct OSQPInfo {
    #[doc = "< Status string, e.g. 'solved'"]
    pub status: [::std::os::raw::c_char; 32usize],
    #[doc = "< Status as OSQPInt, defined in osqp_api_constants.h"]
    pub status_val: OSQPInt,
    #[doc = "< Polishing status: successful (1), unperformed (0), unsuccessful (-1)"]
    pub status_polish: OSQPInt,
    #[doc = "< Primal objective value"]
    pub obj_val: OSQPFloat,
    #[doc = "< Dual objective value"]
    pub dual_obj_val: OSQPFloat,
    #[doc = "< Norm of primal residual"]
    pub prim_res: OSQPFloat,
    #[doc = "< Norm of dual residual"]
    pub dual_res: OSQPFloat,
    #[doc = "< Duality gap (Primal obj - Dual obj)"]
    pub duality_gap: OSQPFloat,
    #[doc = "< Number of iterations taken"]
    pub iter: OSQPInt,
    #[doc = "< Number of rho updates performned"]
    pub rho_updates: OSQPInt,
    #[doc = "< Best rho estimate so far from residuals"]
    pub rho_estimate: OSQPFloat,
    #[doc = "< Setup phase time (seconds)"]
    pub setup_time: OSQPFloat,
    #[doc = "< Solve phase time (seconds)"]
    pub solve_time: OSQPFloat,
    #[doc = "< Update phase time (seconds)"]
    pub update_time: OSQPFloat,
    #[doc = "< Polish phase time (seconds)"]
    pub polish_time: OSQPFloat,
    #[doc = "< Total solve time (seconds)"]
    pub run_time: OSQPFloat,
    #[doc = "< Integral of duality gap over time (Primal-dual integral), requires profiling"]
    pub primdual_int: OSQPFloat,
    #[doc = "< Relative KKT error"]
    pub rel_kkt_error: OSQPFloat,
}
#[doc = " Structure to hold the computed solution (if any), and any certificates of\n infeasibility (if any) found by the solver."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSQPSolution {
    #[doc = "< Primal solution"]
    pub x: *mut OSQPFloat,
    #[doc = "< Lagrange multiplier associated with \\f$l \\le Ax \\le u\\f$"]
    pub y: *mut OSQPFloat,
    #[doc = "< Primal infeasibility certificate"]
    pub prim_inf_cert: *mut OSQPFloat,
    #[doc = "< Dual infeasibility certificate"]
    pub dual_inf_cert: *mut OSQPFloat,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSQPWorkspace_ {
    _unused: [u8; 0],
}
pub type OSQPWorkspace = OSQPWorkspace_;
#[doc = " Main OSQP solver structure that holds all information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSQPSolver {
    #[doc = "< Problem settings"]
    pub settings: *mut OSQPSettings,
    #[doc = "< Computed solution"]
    pub solution: *mut OSQPSolution,
    #[doc = "< Solver information"]
    pub info: *mut OSQPInfo,
    #[doc = "< Internal solver workspace (contents not public)"]
    pub work: *mut OSQPWorkspace,
}
extern "C" {
    #[doc = " Allocates a new Compressed-Column-Sparse (CSC) matrix from existing arrays.\n\n This will malloc the new matrix structure, but use the arrays passed in as the\n backing data for the matrix (e.g. not copy the actual matrix data, just reference\n the existing data.)\n\n @note Not available in embedded mode (requires malloc)\n\n @param  m     Number of rows\n @param  n     number of columns\n @param  nzmax Maximum number of nonzero elements\n @param  x     Vector of data\n @param  i     Vector of row indices\n @param  p     Vector of column pointers\n @return       Pointer to new CSC matrix, or null on error"]
    pub fn OSQPCscMatrix_new(
        m: OSQPInt,
        n: OSQPInt,
        nzmax: OSQPInt,
        x: *mut OSQPFloat,
        i: *mut OSQPInt,
        p: *mut OSQPInt,
    ) -> *mut OSQPCscMatrix;
}
extern "C" {
    #[doc = " Free a CSC matrix object allocated by @ref OSQPCscMatrix_new.\n\n @note This function will only free the internal @ref OSQPCscMatrix.x, @ref OSQPCscMatrix.p,\n @ref OSQPCscMatrix.i arrays if the @ref OSQPCscMatrix.owned variable is set to `1`, otherwise\n only the outer CSC wrapper is free'd.\n\n @note Not available in embedded mode (requires free)\n\n @param mat Matrix to free"]
    pub fn OSQPCscMatrix_free(mat: *mut OSQPCscMatrix);
}
extern "C" {
    #[doc = " Allocate a new OSQPSettings object with the default settings.\n\n @note Not available in embedded mode (requires malloc)\n\n @return Pointer to new settings object, or null on error"]
    pub fn OSQPSettings_new() -> *mut OSQPSettings;
}
extern "C" {
    #[doc = " Free an OSQPSettings object.\n\n @note Not available in embedded mode (requires free)\n\n @param settings The settings object to free"]
    pub fn OSQPSettings_free(settings: *mut OSQPSettings);
}
extern "C" {
    #[doc = " Return OSQP version\n\n @return OSQP version string"]
    pub fn osqp_version() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Initialize OSQP solver allocating memory.\n\n It performs:\n - data and settings validation\n - problem data scaling\n - setup linear system solver:\n      - direct solver: KKT matrix factorization is performed here\n      - indirect solver: reduced KKT matrix preconditioning is performed here\n\n NB: This is the only function that allocates dynamic memory and is not used\n during code generation\n\n @param  solverp   Solver pointer\n @param  P         Problem data (upper triangular part of quadratic cost term, csc format)\n @param  q         Problem data (linear cost term)\n @param  A         Problem data (constraint matrix, csc format)\n @param  l         Problem data (constraint lower bound)\n @param  u         Problem data (constraint upper bound)\n @param  m         Problem data (number of constraints)\n @param  n         Problem data (number of variables)\n @param  settings  Solver settings\n @return           Exitflag for errors (0 if no errors)"]
    pub fn osqp_setup(
        solverp: *mut *mut OSQPSolver,
        P: *const OSQPCscMatrix,
        q: *const OSQPFloat,
        A: *const OSQPCscMatrix,
        l: *const OSQPFloat,
        u: *const OSQPFloat,
        m: OSQPInt,
        n: OSQPInt,
        settings: *const OSQPSettings,
    ) -> OSQPInt;
}
extern "C" {
    #[doc = " Solve quadratic program\n\n The final solver information is stored in the  \\a solver->info  structure\n\n The solution is stored in the  \\a solver->solution  structure\n\n If the problem is primal infeasible, the certificate is stored\n in \\a solver->delta_y\n\n If the problem is dual infeasible, the certificate is stored in \\a\n solver->delta_x\n\n @param  solver Solver\n @return        Exitflag for errors (0 if no errors)"]
    pub fn osqp_solve(solver: *mut OSQPSolver) -> OSQPInt;
}
extern "C" {
    #[doc = " Cleanup workspace by deallocating memory\n\n This function is not used in code generation\n @param  solver Solver\n @return        Exitflag for errors (0 if no errors)"]
    pub fn osqp_cleanup(solver: *mut OSQPSolver) -> OSQPInt;
}
extern "C" {
    #[doc = " Warm start primal and dual variables\n @param  solver Solver\n @param  x      Primal variable, NULL if none\n @param  y      Dual variable, NULL if none\n @return        Exitflag for errors (0 if no errors)"]
    pub fn osqp_warm_start(
        solver: *mut OSQPSolver,
        x: *const OSQPFloat,
        y: *const OSQPFloat,
    ) -> OSQPInt;
}
extern "C" {
    #[doc = " Update problem data vectors\n @param  solver  Solver\n @param  q_new   New linear cost, NULL if none\n @param  l_new   New lower bound, NULL if none\n @param  u_new   New upper bound, NULL if none\n @return         Exitflag for errors (0 if no errors)"]
    pub fn osqp_update_data_vec(
        solver: *mut OSQPSolver,
        q_new: *const OSQPFloat,
        l_new: *const OSQPFloat,
        u_new: *const OSQPFloat,
    ) -> OSQPInt;
}
extern "C" {
    #[doc = " Update elements of matrices P (upper triangular) and A by preserving\n their sparsity structures.\n\n If Px_new_idx (Ax_new_idx) is OSQP_NULL, Px_new (Ax_new) is assumed\n to be as long as P->x (A->x) and the whole P->x (A->x) is replaced.\n\n @param  solver     Solver\n @param  Px_new     Vector of new elements in P->x (upper triangular), NULL if none\n @param  Px_new_idx Index mapping new elements to positions in P->x\n @param  P_new_n    Number of new elements to be changed\n @param  Ax_new     Vector of new elements in A->x, NULL if none\n @param  Ax_new_idx Index mapping new elements to positions in A->x\n @param  A_new_n    Number of new elements to be changed\n @return            output flag:  0: OK\n                                  1: P_new_n > nnzP\n                                  2: A_new_n > nnzA\n                                 <0: error in the update"]
    pub fn osqp_update_data_mat(
        solver: *mut OSQPSolver,
        Px_new: *const OSQPFloat,
        Px_new_idx: *const OSQPInt,
        P_new_n: OSQPInt,
        Ax_new: *const OSQPFloat,
        Ax_new_idx: *const OSQPInt,
        A_new_n: OSQPInt,
    ) -> OSQPInt;
}
extern "C" {
    #[doc = " Get the default settings from the osqp_api_constants.h file.\n\n @note the @c settings parameter must already be allocated in memory.\n\n @param settings Settings structure to populate"]
    pub fn osqp_set_default_settings(settings: *mut OSQPSettings);
}
extern "C" {
    #[doc = " Update the ADMM parameter rho.\n\n Limit it between OSQP_RHO_MIN and OSQP_RHO_MAX.\n\n @param  solver  Solver\n @param  rho_new New rho value\n @return         Exitflag for errors (0 if no errors)"]
    pub fn osqp_update_rho(solver: *mut OSQPSolver, rho_new: OSQPFloat) -> OSQPInt;
}
extern "C" {
    #[doc = " Update problem settings.\n\n @param  solver  Solver\n @param new_settings Settings structure to copy from"]
    pub fn osqp_update_settings(
        solver: *mut OSQPSolver,
        new_settings: *mut OSQPSettings,
    ) -> OSQPInt;
}
