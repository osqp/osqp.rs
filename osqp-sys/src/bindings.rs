/* automatically generated by rust-bindgen 0.70.1 */

use {c_float, c_int, OSQPTimer};

pub const QDLDL_SOLVER: linsys_solver_type = 0;
pub const MKL_PARDISO_SOLVER: linsys_solver_type = 1;
pub const UNKNOWN_SOLVER: linsys_solver_type = 99;
#[doc = " Linear System Solvers *"]
pub type linsys_solver_type = ::std::os::raw::c_uint;
pub const OSQP_DATA_VALIDATION_ERROR: osqp_error_type = 1;
pub const OSQP_SETTINGS_VALIDATION_ERROR: osqp_error_type = 2;
pub const OSQP_LINSYS_SOLVER_LOAD_ERROR: osqp_error_type = 3;
pub const OSQP_LINSYS_SOLVER_INIT_ERROR: osqp_error_type = 4;
pub const OSQP_NONCVX_ERROR: osqp_error_type = 5;
pub const OSQP_MEM_ALLOC_ERROR: osqp_error_type = 6;
pub const OSQP_WORKSPACE_NOT_INIT_ERROR: osqp_error_type = 7;
#[doc = " Solver Errors  *"]
pub type osqp_error_type = ::std::os::raw::c_uint;
#[doc = "  Matrix in compressed-column form.\n  The structure is used internally to store matrices in the triplet form as well,\n  but the API requires that the matrices are in the CSC format."]
#[repr(C)]
pub struct csc {
    #[doc = "< maximum number of entries"]
    pub nzmax: c_int,
    #[doc = "< number of rows"]
    pub m: c_int,
    #[doc = "< number of columns"]
    pub n: c_int,
    #[doc = "< column pointers (size n+1); col indices (size nzmax) start from 0 when using triplet format (direct KKT matrix formation)"]
    pub p: *mut c_int,
    #[doc = "< row indices, size nzmax starting from 0"]
    pub i: *mut c_int,
    #[doc = "< numerical values, size nzmax"]
    pub x: *mut c_float,
    #[doc = "< number of entries in triplet matrix, -1 for csc"]
    pub nz: c_int,
}
#[doc = " Linear system solver structure (sublevel objects initialize it differently)"]
pub type LinSysSolver = linsys_solver;
#[doc = " Problem scaling matrices stored as vectors"]
#[repr(C)]
pub struct OSQPScaling {
    #[doc = "< cost function scaling"]
    pub c: c_float,
    #[doc = "< primal variable scaling"]
    pub D: *mut c_float,
    #[doc = "< dual variable scaling"]
    pub E: *mut c_float,
    #[doc = "< cost function rescaling"]
    pub cinv: c_float,
    #[doc = "< primal variable rescaling"]
    pub Dinv: *mut c_float,
    #[doc = "< dual variable rescaling"]
    pub Einv: *mut c_float,
}
#[doc = " Solution structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSQPSolution {
    #[doc = "< primal solution"]
    pub x: *mut c_float,
    #[doc = "< Lagrange multiplier associated to \\f$l <= Ax <= u\\f$"]
    pub y: *mut c_float,
}
#[doc = " Solver return information"]
#[repr(C)]
pub struct OSQPInfo {
    #[doc = "< number of iterations taken"]
    pub iter: c_int,
    #[doc = "< status string, e.g. 'solved'"]
    pub status: [::std::os::raw::c_char; 32usize],
    #[doc = "< status as c_int, defined in constants.h"]
    pub status_val: c_int,
    #[doc = "< polish status: successful (1), unperformed (0), (-1) unsuccessful"]
    pub status_polish: c_int,
    #[doc = "< primal objective"]
    pub obj_val: c_float,
    #[doc = "< norm of primal residual"]
    pub pri_res: c_float,
    #[doc = "< norm of dual residual"]
    pub dua_res: c_float,
    #[doc = "< time taken for setup phase (seconds)"]
    pub setup_time: c_float,
    #[doc = "< time taken for solve phase (seconds)"]
    pub solve_time: c_float,
    #[doc = "< time taken for update phase (seconds)"]
    pub update_time: c_float,
    #[doc = "< time taken for polish phase (seconds)"]
    pub polish_time: c_float,
    #[doc = "< total time  (seconds)"]
    pub run_time: c_float,
    #[doc = "< number of rho updates"]
    pub rho_updates: c_int,
    #[doc = "< best rho estimate so far from residuals"]
    pub rho_estimate: c_float,
}
#[doc = " Polish structure"]
#[repr(C)]
pub struct OSQPPolish {
    #[doc = "< active rows of A\n<    Ared = vstack[Alow, Aupp]"]
    pub Ared: *mut csc,
    #[doc = "< number of lower-active rows"]
    pub n_low: c_int,
    #[doc = "< number of upper-active rows"]
    pub n_upp: c_int,
    #[doc = "< Maps indices in A to indices in Alow"]
    pub A_to_Alow: *mut c_int,
    #[doc = "< Maps indices in A to indices in Aupp"]
    pub A_to_Aupp: *mut c_int,
    #[doc = "< Maps indices in Alow to indices in A"]
    pub Alow_to_A: *mut c_int,
    #[doc = "< Maps indices in Aupp to indices in A"]
    pub Aupp_to_A: *mut c_int,
    #[doc = "< optimal x-solution obtained by polish"]
    pub x: *mut c_float,
    #[doc = "< optimal z-solution obtained by polish"]
    pub z: *mut c_float,
    #[doc = "< optimal y-solution obtained by polish"]
    pub y: *mut c_float,
    #[doc = "< objective value at polished solution"]
    pub obj_val: c_float,
    #[doc = "< primal residual at polished solution"]
    pub pri_res: c_float,
    #[doc = "< dual residual at polished solution"]
    pub dua_res: c_float,
}
#[doc = " Data structure"]
#[repr(C)]
pub struct OSQPData {
    #[doc = "< number of variables n"]
    pub n: c_int,
    #[doc = "< number of constraints m"]
    pub m: c_int,
    #[doc = "< the upper triangular part of the quadratic cost matrix P in csc format (size n x n)."]
    pub P: *mut csc,
    #[doc = "< linear constraints matrix A in csc format (size m x n)"]
    pub A: *mut csc,
    #[doc = "< dense array for linear part of cost function (size n)"]
    pub q: *mut c_float,
    #[doc = "< dense array for lower bound (size m)"]
    pub l: *mut c_float,
    #[doc = "< dense array for upper bound (size m)"]
    pub u: *mut c_float,
}
#[doc = " Settings struct"]
#[repr(C)]
pub struct OSQPSettings {
    #[doc = "< ADMM step rho"]
    pub rho: c_float,
    #[doc = "< ADMM step sigma"]
    pub sigma: c_float,
    #[doc = "< heuristic data scaling iterations; if 0, then disabled."]
    pub scaling: c_int,
    #[doc = "< boolean, is rho step size adaptive?"]
    pub adaptive_rho: c_int,
    #[doc = "< number of iterations between rho adaptations; if 0, then it is automatic"]
    pub adaptive_rho_interval: c_int,
    #[doc = "< tolerance X for adapting rho. The new rho has to be X times larger or 1/X times smaller than the current one to trigger a new factorization."]
    pub adaptive_rho_tolerance: c_float,
    #[doc = "< interval for adapting rho (fraction of the setup time)"]
    pub adaptive_rho_fraction: c_float,
    #[doc = "< maximum number of iterations"]
    pub max_iter: c_int,
    #[doc = "< absolute convergence tolerance"]
    pub eps_abs: c_float,
    #[doc = "< relative convergence tolerance"]
    pub eps_rel: c_float,
    #[doc = "< primal infeasibility tolerance"]
    pub eps_prim_inf: c_float,
    #[doc = "< dual infeasibility tolerance"]
    pub eps_dual_inf: c_float,
    #[doc = "< relaxation parameter"]
    pub alpha: c_float,
    #[doc = "< linear system solver to use"]
    pub linsys_solver: linsys_solver_type,
    #[doc = "< regularization parameter for polishing"]
    pub delta: c_float,
    #[doc = "< boolean, polish ADMM solution"]
    pub polish: c_int,
    #[doc = "< number of iterative refinement steps in polishing"]
    pub polish_refine_iter: c_int,
    #[doc = "< boolean, write out progress"]
    pub verbose: c_int,
    #[doc = "< boolean, use scaled termination criteria"]
    pub scaled_termination: c_int,
    #[doc = "< integer, check termination interval; if 0, then termination checking is disabled"]
    pub check_termination: c_int,
    #[doc = "< boolean, warm start"]
    pub warm_start: c_int,
    #[doc = "< maximum number of seconds allowed to solve the problem; if 0, then disabled"]
    pub time_limit: c_float,
}
#[doc = " OSQP Workspace"]
#[repr(C)]
pub struct OSQPWorkspace {
    #[doc = " Problem data to work on (possibly scaled)"]
    pub data: *mut OSQPData,
    #[doc = " Linear System solver structure"]
    pub linsys_solver: *mut LinSysSolver,
    #[doc = " Polish structure"]
    pub pol: *mut OSQPPolish,
    #[doc = "< vector of rho values"]
    pub rho_vec: *mut c_float,
    #[doc = "< vector of inv rho values"]
    pub rho_inv_vec: *mut c_float,
    #[doc = "< Type of constraints: loose (-1), equality (1), inequality (0)"]
    pub constr_type: *mut c_int,
    #[doc = "< Iterate x"]
    pub x: *mut c_float,
    #[doc = "< Iterate y"]
    pub y: *mut c_float,
    #[doc = "< Iterate z"]
    pub z: *mut c_float,
    #[doc = "< Iterate xz_tilde"]
    pub xz_tilde: *mut c_float,
    #[doc = "< Previous x"]
    pub x_prev: *mut c_float,
    #[doc = "< Previous z"]
    pub z_prev: *mut c_float,
    #[doc = "< scaled A * x"]
    pub Ax: *mut c_float,
    #[doc = "< scaled P * x"]
    pub Px: *mut c_float,
    #[doc = "< scaled A' * y"]
    pub Aty: *mut c_float,
    #[doc = "< difference between consecutive dual iterates"]
    pub delta_y: *mut c_float,
    #[doc = "< A' * delta_y"]
    pub Atdelta_y: *mut c_float,
    #[doc = "< difference between consecutive primal iterates"]
    pub delta_x: *mut c_float,
    #[doc = "< P * delta_x"]
    pub Pdelta_x: *mut c_float,
    #[doc = "< A * delta_x"]
    pub Adelta_x: *mut c_float,
    #[doc = "< temporary primal variable scaling vectors"]
    pub D_temp: *mut c_float,
    #[doc = "< temporary primal variable scaling vectors storing norms of A columns"]
    pub D_temp_A: *mut c_float,
    #[doc = "< temporary constraints scaling vectors storing norms of A' columns"]
    pub E_temp: *mut c_float,
    #[doc = "< problem settings"]
    pub settings: *mut OSQPSettings,
    #[doc = "< scaling vectors"]
    pub scaling: *mut OSQPScaling,
    #[doc = "< problem solution"]
    pub solution: *mut OSQPSolution,
    #[doc = "< solver information"]
    pub info: *mut OSQPInfo,
    #[doc = "< timer object"]
    pub timer: *mut OSQPTimer,
    #[doc = " flag indicating whether the solve function has been run before"]
    pub first_run: c_int,
    #[doc = " flag indicating whether the update_time should be cleared"]
    pub clear_update_time: c_int,
    #[doc = " flag indicating that osqp_update_rho is called from osqp_solve function"]
    pub rho_update_from_solve: c_int,
    #[doc = "< Has last summary been printed? (true/false)"]
    pub summary_printed: c_int,
}
#[doc = " Define linsys_solver prototype structure\n\n NB: The details are defined when the linear solver is initialized depending\n      on the choice"]
#[repr(C)]
pub struct linsys_solver {
    #[doc = "< linear system solver type functions"]
    pub type_: linsys_solver_type,
    pub solve: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut LinSysSolver, b: *mut c_float) -> c_int,
    >,
    #[doc = "< free linear system solver (only in desktop version)"]
    pub free: ::std::option::Option<unsafe extern "C" fn(self_: *mut LinSysSolver)>,
    pub update_matrices: ::std::option::Option<
        unsafe extern "C" fn(s: *mut LinSysSolver, P: *const csc, A: *const csc) -> c_int,
    >,
    pub update_rho_vec: ::std::option::Option<
        unsafe extern "C" fn(s: *mut LinSysSolver, rho_vec: *const c_float) -> c_int,
    >,
    #[doc = "< number of threads active"]
    pub nthreads: c_int,
}
extern "C" {
    #[doc = " Set default settings from constants.h file\n assumes settings already allocated in memory\n @param settings settings structure"]
    pub fn osqp_set_default_settings(settings: *mut OSQPSettings);
}
extern "C" {
    #[doc = " Initialize OSQP solver allocating memory.\n\n All the inputs must be already allocated in memory before calling.\n\n It performs:\n - data and settings validation\n - problem data scaling\n - automatic parameters tuning (if enabled)\n - setup linear system solver:\n      - direct solver: KKT matrix factorization is performed here\n      - indirect solver: KKT matrix preconditioning is performed here\n\n NB: This is the only function that allocates dynamic memory and is not used\nduring code generation\n\n @param  workp        Solver workspace pointer\n @param  data         Problem data\n @param  settings     Solver settings\n @return              Exitflag for errors (0 if no errors)"]
    pub fn osqp_setup(
        workp: *mut *mut OSQPWorkspace,
        data: *const OSQPData,
        settings: *const OSQPSettings,
    ) -> c_int;
}
extern "C" {
    #[doc = " Solve quadratic program\n\n The final solver information is stored in the \\a work->info  structure\n\n The solution is stored in the  \\a work->solution  structure\n\n If the problem is primal infeasible, the certificate is stored\n in \\a work->delta_y\n\n If the problem is dual infeasible, the certificate is stored in \\a\n work->delta_x\n\n @param  work Workspace allocated\n @return      Exitflag for errors"]
    pub fn osqp_solve(work: *mut OSQPWorkspace) -> c_int;
}
extern "C" {
    #[doc = " Cleanup workspace by deallocating memory\n\n This function is not used in code generation\n @param  work Workspace\n @return      Exitflag for errors"]
    pub fn osqp_cleanup(work: *mut OSQPWorkspace) -> c_int;
}
extern "C" {
    #[doc = " Update linear cost in the problem\n @param  work  Workspace\n @param  q_new New linear cost\n @return       Exitflag for errors and warnings"]
    pub fn osqp_update_lin_cost(work: *mut OSQPWorkspace, q_new: *const c_float) -> c_int;
}
extern "C" {
    #[doc = " Update lower and upper bounds in the problem constraints\n @param  work   Workspace\n @param  l_new New lower bound\n @param  u_new New upper bound\n @return        Exitflag: 1 if new lower bound is not <= than new upper bound"]
    pub fn osqp_update_bounds(
        work: *mut OSQPWorkspace,
        l_new: *const c_float,
        u_new: *const c_float,
    ) -> c_int;
}
extern "C" {
    #[doc = " Update lower bound in the problem constraints\n @param  work   Workspace\n @param  l_new New lower bound\n @return        Exitflag: 1 if new lower bound is not <= than upper bound"]
    pub fn osqp_update_lower_bound(work: *mut OSQPWorkspace, l_new: *const c_float) -> c_int;
}
extern "C" {
    #[doc = " Update upper bound in the problem constraints\n @param  work   Workspace\n @param  u_new New upper bound\n @return        Exitflag: 1 if new upper bound is not >= than lower bound"]
    pub fn osqp_update_upper_bound(work: *mut OSQPWorkspace, u_new: *const c_float) -> c_int;
}
extern "C" {
    #[doc = " Warm start primal and dual variables\n @param  work Workspace structure\n @param  x    Primal variable\n @param  y    Dual variable\n @return      Exitflag"]
    pub fn osqp_warm_start(work: *mut OSQPWorkspace, x: *const c_float, y: *const c_float)
        -> c_int;
}
extern "C" {
    #[doc = " Warm start primal variable\n @param  work Workspace structure\n @param  x    Primal variable\n @return      Exitflag"]
    pub fn osqp_warm_start_x(work: *mut OSQPWorkspace, x: *const c_float) -> c_int;
}
extern "C" {
    #[doc = " Warm start dual variable\n @param  work Workspace structure\n @param  y    Dual variable\n @return      Exitflag"]
    pub fn osqp_warm_start_y(work: *mut OSQPWorkspace, y: *const c_float) -> c_int;
}
extern "C" {
    #[doc = " Update elements of matrix P (upper triangular)\n without changing sparsity structure.\n\n\n  If Px_new_idx is OSQP_NULL, Px_new is assumed to be as long as P->x\n  and the whole P->x is replaced.\n\n @param  work       Workspace structure\n @param  Px_new     Vector of new elements in P->x (upper triangular)\n @param  Px_new_idx Index mapping new elements to positions in P->x\n @param  P_new_n    Number of new elements to be changed\n @return            output flag:  0: OK\n                                  1: P_new_n > nnzP\n                                 <0: error in the update"]
    pub fn osqp_update_P(
        work: *mut OSQPWorkspace,
        Px_new: *const c_float,
        Px_new_idx: *const c_int,
        P_new_n: c_int,
    ) -> c_int;
}
extern "C" {
    #[doc = " Update elements of matrix A without changing sparsity structure.\n\n\n  If Ax_new_idx is OSQP_NULL, Ax_new is assumed to be as long as A->x\n  and the whole A->x is replaced.\n\n @param  work       Workspace structure\n @param  Ax_new     Vector of new elements in A->x\n @param  Ax_new_idx Index mapping new elements to positions in A->x\n @param  A_new_n    Number of new elements to be changed\n @return            output flag:  0: OK\n                                  1: A_new_n > nnzA\n                                 <0: error in the update"]
    pub fn osqp_update_A(
        work: *mut OSQPWorkspace,
        Ax_new: *const c_float,
        Ax_new_idx: *const c_int,
        A_new_n: c_int,
    ) -> c_int;
}
extern "C" {
    #[doc = " Update elements of matrix P (upper triangular) and elements of matrix A\n without changing sparsity structure.\n\n\n  If Px_new_idx is OSQP_NULL, Px_new is assumed to be as long as P->x\n  and the whole P->x is replaced.\n\n  If Ax_new_idx is OSQP_NULL, Ax_new is assumed to be as long as A->x\n  and the whole A->x is replaced.\n\n @param  work       Workspace structure\n @param  Px_new     Vector of new elements in P->x (upper triangular)\n @param  Px_new_idx Index mapping new elements to positions in P->x\n @param  P_new_n    Number of new elements to be changed\n @param  Ax_new     Vector of new elements in A->x\n @param  Ax_new_idx Index mapping new elements to positions in A->x\n @param  A_new_n    Number of new elements to be changed\n @return            output flag:  0: OK\n                                  1: P_new_n > nnzP\n                                  2: A_new_n > nnzA\n                                 <0: error in the update"]
    pub fn osqp_update_P_A(
        work: *mut OSQPWorkspace,
        Px_new: *const c_float,
        Px_new_idx: *const c_int,
        P_new_n: c_int,
        Ax_new: *const c_float,
        Ax_new_idx: *const c_int,
        A_new_n: c_int,
    ) -> c_int;
}
extern "C" {
    #[doc = " Update rho. Limit it between RHO_MIN and RHO_MAX.\n @param  work         Workspace\n @param  rho_new      New rho setting\n @return              Exitflag"]
    pub fn osqp_update_rho(work: *mut OSQPWorkspace, rho_new: c_float) -> c_int;
}
extern "C" {
    #[doc = " Update max_iter setting\n @param  work         Workspace\n @param  max_iter_new New max_iter setting\n @return              Exitflag"]
    pub fn osqp_update_max_iter(work: *mut OSQPWorkspace, max_iter_new: c_int) -> c_int;
}
extern "C" {
    #[doc = " Update absolute tolernace value\n @param  work        Workspace\n @param  eps_abs_new New absolute tolerance value\n @return             Exitflag"]
    pub fn osqp_update_eps_abs(work: *mut OSQPWorkspace, eps_abs_new: c_float) -> c_int;
}
extern "C" {
    #[doc = " Update relative tolernace value\n @param  work        Workspace\n @param  eps_rel_new New relative tolerance value\n @return             Exitflag"]
    pub fn osqp_update_eps_rel(work: *mut OSQPWorkspace, eps_rel_new: c_float) -> c_int;
}
extern "C" {
    #[doc = " Update primal infeasibility tolerance\n @param  work          Workspace\n @param  eps_prim_inf_new  New primal infeasibility tolerance\n @return               Exitflag"]
    pub fn osqp_update_eps_prim_inf(work: *mut OSQPWorkspace, eps_prim_inf_new: c_float) -> c_int;
}
extern "C" {
    #[doc = " Update dual infeasibility tolerance\n @param  work          Workspace\n @param  eps_dual_inf_new  New dual infeasibility tolerance\n @return               Exitflag"]
    pub fn osqp_update_eps_dual_inf(work: *mut OSQPWorkspace, eps_dual_inf_new: c_float) -> c_int;
}
extern "C" {
    #[doc = " Update relaxation parameter alpha\n @param  work  Workspace\n @param  alpha_new New relaxation parameter value\n @return       Exitflag"]
    pub fn osqp_update_alpha(work: *mut OSQPWorkspace, alpha_new: c_float) -> c_int;
}
extern "C" {
    #[doc = " Update warm_start setting\n @param  work           Workspace\n @param  warm_start_new New warm_start setting\n @return                Exitflag"]
    pub fn osqp_update_warm_start(work: *mut OSQPWorkspace, warm_start_new: c_int) -> c_int;
}
extern "C" {
    #[doc = " Update scaled_termination setting\n @param  work                 Workspace\n @param  scaled_termination_new  New scaled_termination setting\n @return                      Exitflag"]
    pub fn osqp_update_scaled_termination(
        work: *mut OSQPWorkspace,
        scaled_termination_new: c_int,
    ) -> c_int;
}
extern "C" {
    #[doc = " Update check_termination setting\n @param  work                   Workspace\n @param  check_termination_new  New check_termination setting\n @return                        Exitflag"]
    pub fn osqp_update_check_termination(
        work: *mut OSQPWorkspace,
        check_termination_new: c_int,
    ) -> c_int;
}
extern "C" {
    #[doc = " Update regularization parameter in polish\n @param  work      Workspace\n @param  delta_new New regularization parameter\n @return           Exitflag"]
    pub fn osqp_update_delta(work: *mut OSQPWorkspace, delta_new: c_float) -> c_int;
}
extern "C" {
    #[doc = " Update polish setting\n @param  work          Workspace\n @param  polish_new New polish setting\n @return               Exitflag"]
    pub fn osqp_update_polish(work: *mut OSQPWorkspace, polish_new: c_int) -> c_int;
}
extern "C" {
    #[doc = " Update number of iterative refinement steps in polish\n @param  work                Workspace\n @param  polish_refine_iter_new New iterative reginement steps\n @return                     Exitflag"]
    pub fn osqp_update_polish_refine_iter(
        work: *mut OSQPWorkspace,
        polish_refine_iter_new: c_int,
    ) -> c_int;
}
extern "C" {
    #[doc = " Update verbose setting\n @param  work        Workspace\n @param  verbose_new New verbose setting\n @return             Exitflag"]
    pub fn osqp_update_verbose(work: *mut OSQPWorkspace, verbose_new: c_int) -> c_int;
}
extern "C" {
    #[doc = " Update time_limit setting\n @param  work            Workspace\n @param  time_limit_new  New time_limit setting\n @return                 Exitflag"]
    pub fn osqp_update_time_limit(work: *mut OSQPWorkspace, time_limit_new: c_float) -> c_int;
}
pub const OSQP_DUAL_INFEASIBLE_INACCURATE: ffi_osqp_solve_status = 4;
pub const OSQP_PRIMAL_INFEASIBLE_INACCURATE: ffi_osqp_solve_status = 3;
pub const OSQP_SOLVED_INACCURATE: ffi_osqp_solve_status = 2;
pub const OSQP_SOLVED: ffi_osqp_solve_status = 1;
pub const OSQP_MAX_ITER_REACHED: ffi_osqp_solve_status = -2;
pub const OSQP_PRIMAL_INFEASIBLE: ffi_osqp_solve_status = -3;
pub const OSQP_DUAL_INFEASIBLE: ffi_osqp_solve_status = -4;
pub const OSQP_SIGINT: ffi_osqp_solve_status = -5;
pub const OSQP_TIME_LIMIT_REACHED: ffi_osqp_solve_status = -6;
pub const OSQP_NON_CVX: ffi_osqp_solve_status = -7;
pub const OSQP_UNSOLVED: ffi_osqp_solve_status = -10;
pub type ffi_osqp_solve_status = ::std::os::raw::c_int;
